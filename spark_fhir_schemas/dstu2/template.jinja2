from typing import Union, List, Optional

from pyspark.sql.types import StructType, StructField, StringType, ArrayType, DateType, BooleanType, IntegerType, \
    DataType, TimestampType, FloatType


# This file is auto-generated by generate_schema so do not edit manually
# noinspection PyPep8Naming
class {{fhir_entity.cleaned_name}}Schema:
    """
{% for documentation_item in fhir_entity.documentation %}
    {{ documentation_item | wordwrap(78) | replace('\n', '\n    ') | replace('\r', '\n    ') }}
{% endfor %}
    """
    # noinspection PyDefaultArgument
    @staticmethod
    def get_schema(max_nesting_depth: Optional[int] = 6, nesting_depth: int = 0, nesting_list: List[str] = [], max_recursion_limit: Optional[int] = 2, include_extension: Optional[bool] = False, extension_fields: Optional[List[str]] = ["valueBoolean","valueCode","valueDate","valueDateTime","valueDecimal","valueId","valueInteger","valuePositiveInt","valueString","valueTime","valueUnsignedInt","valueUri", "valueQuantity"], extension_depth: int = 0, max_extension_depth: Optional[int] = 2) -> Union[StructType, DataType]:
        """
{% for documentation_item in fhir_entity.documentation %}
    {{ documentation_item | wordwrap(78) | replace('\n', '\n    ') | replace('\r', '\n    ') }}
{% endfor %}


    {% for property in fhir_entity.properties%}
        {{ property.name }}: {{ property.documentation[0] | wordwrap(78) | replace('\n', '\n    ') | replace('\r', '\n    ') }}
    {%  endfor %}
        """
{% for property in fhir_entity.properties %}
    {% if property.cleaned_type and property.cleaned_type not in ["string","boolean","date","number"] %}
        {%  if property.cleaned_type != fhir_entity.cleaned_name %}
            # {{ property.name }}
            {% if property.is_resource %}
        from spark_fhir_schemas.dstu2.resources.{{property.cleaned_type.lower()}} import {{property.cleaned_type}}Schema
            {% elif property.is_code %}
             # type = code
            {% elif property.type_ == "string" %}
             # type = string
            {% elif property.is_basic_type %}
        from spark_fhir_schemas.dstu2.simple_types.{{property.type_.lower()}} import {{property.type_}}Schema
            {% elif property.is_complex or property.fhir_type == "Element" %}
        from spark_fhir_schemas.dstu2.complex_types.{{property.cleaned_type.lower()}} import {{property.cleaned_type}}Schema
            {% else %}
        Not mapped: {{ property.cleaned_type }}
            {% endif %}
        {% endif %}
    {% endif %}
{% endfor %}
{% if not fhir_entity.properties %}
{#    if it is a simple property #}
    {% if fhir_entity.base_type == "string" %}
        return StringType()
    {% elif fhir_entity.base_type == "boolean" %}
        return BooleanType()
    {% elif fhir_entity.base_type == "date"  or fhir_entity.cleaned_name.lower() == "date"%}
        return DateType()
    {% elif fhir_entity.base_type == "integer" and ("Decimal" in fhir_entity.cleaned_name) %}
        return FloatType()
    {% elif fhir_entity.base_type == "integer" %}
        return IntegerType()
    {% elif fhir_entity.type_ == "Element" %}
        return StringType()
    {% elif fhir_entity.base_type == "uri" %}
        return StringType()
    {%  elif not fhir_entity.base_type %}
        return StringType()
    {%  else %}
        Error: No mapping for {{ fhir_entity.type_ }}
    {% endif %}
{%  else %}
        if (max_recursion_limit and nesting_list.count("{{fhir_entity.cleaned_name}}") >= max_recursion_limit) or (max_nesting_depth and nesting_depth >= max_nesting_depth):
{#            print("reached nesting_depth for {{fhir_entity.cleaned_name}}")#}
            return StructType([StructField("id", StringType(), True)])
    {% if fhir_entity.cleaned_name == "Extension" %}
        if max_extension_depth and extension_depth >= max_extension_depth:
            return StructType([StructField("id", StringType(), True)])
    {%  endif %}
    {%  if not fhir_entity.properties or fhir_entity.properties | length == 0 %}
        # Return at least one field in the struct or Spark throws an error
        # "Datasource does not support writing empty or nested empty schemas"
        return StructType([StructField("id", StringType(), True)])
    {%  else %}
        # add my name to recursion list for later
        my_nesting_list: List[str] = nesting_list+["{{fhir_entity.cleaned_name}}"]
        schema = StructType(
            [
        {% for property in fhir_entity.properties%}
            {% for documentation_item in property.documentation %}
                # {{ documentation_item | wordwrap(78) | replace("\n", "\n                # ") | replace("\r", "\n                # ")}}
            {% endfor %}
            {% if property.HideExtension %}

                # >>> Hiding {{property.name}} {{property.cleaned_type}}

            {% elif property.cleaned_type == "array" %}
                {% if property.base_type and property.base_type not in ["string","boolean","date","number"] %}
                    {% if fhir_entity.cleaned_name == "Extension" and property.name == "extension" %}
                StructField("{{property.name}}",ArrayType({{property.cleaned_type}}Schema.get_schema(max_nesting_depth=max_nesting_depth,nesting_depth=nesting_depth+1,nesting_list=my_nesting_list,max_recursion_limit=max_recursion_limit,include_extension=include_extension,extension_fields=extension_fields, extension_depth=extension_depth+1, max_extension_depth=max_extension_depth)), True),
                    {% else %}
                StructField("{{property.name}}",ArrayType({{property.cleaned_type}}Schema.get_schema(max_nesting_depth=max_nesting_depth,nesting_depth=nesting_depth+1,nesting_list=my_nesting_list,max_recursion_limit=max_recursion_limit,include_extension=include_extension,extension_fields=extension_fields, extension_depth=extension_depth, max_extension_depth=max_extension_depth)), True),
                    {% endif %}
                {% elif property.base_type == "date" or property.cleaned_type == "date" %}
                StructField("{{property.name}}",ArrayType(DateType()), True),
                {% elif (property.base_type == "number" or property.cleaned_type == "number") and ("Decimal" in property.name) %}
                StructField("{{property.name}}",ArrayType(FloatType()), True),
                {%  elif property.base_type == "string" %}
                StructField("{{property.name}}",ArrayType(StringType()), True),
                {% elif property.base_type == "boolean" or property.cleaned_type == "boolean" %}
                StructField("{{property.name}}",ArrayType(BooleanType()), True),
                {% elif property.base_type == "number" or property.cleaned_type == "number" %}
                StructField("{{property.name}}",ArrayType(IntegerType()), True),
                {% endif %}
            {% elif not property.base_type and not property.type_ %}
                StructField("{{property.name}}", StringType(), True),
            {% elif property.base_type == "date" or property.type_ == "date" %}
                StructField("{{property.name}}", DateType(), True),
            {% elif (property.base_type == "number" or property.type_ == "number") and ("Decimal" in property.name) %}
                StructField("{{property.name}}", FloatType(), True),
            {% elif (property.base_type == "number" or property.type_ == "number") and ("\\." in property.Pattern) %}
                StructField("{{property.name}}", FloatType(), True),
            {% elif (property.base_type == "string" or property.type_ == "string") and ("DateTime" in property.name) %}
                StructField("{{property.name}}", TimestampType(), True),
            {% elif (property.base_type == "string" or property.type_ == "string") and ("Date" in property.name) %}
                StructField("{{property.name}}", DateType(), True),
            {% elif property.base_type == "string" or property.type_ == "string" %}
                StructField("{{property.name}}", StringType(), True),
            {% elif property.base_type == "boolean" or property.type_ == "boolean" %}
                StructField("{{property.name}}", BooleanType(), True),
            {% elif property.base_type == "number" or property.type_ == "number" %}
                StructField("{{property.name}}", IntegerType(), True),
            {% elif property.is_code %}
                StructField("{{property.name}}", StringType(), True),
            {% elif property.is_basic_type %}
                StructField("{{property.name}}", {{property.type_}}Schema.get_schema(max_nesting_depth=max_nesting_depth,nesting_depth=nesting_depth+1,nesting_list=my_nesting_list,max_recursion_limit=max_recursion_limit,include_extension=include_extension,extension_fields=extension_fields, extension_depth=extension_depth+1, max_extension_depth=max_extension_depth), True),
            {% else %}
                StructField("{{property.name}}", {{property.cleaned_type}}Schema.get_schema(max_nesting_depth=max_nesting_depth,nesting_depth=nesting_depth+1,nesting_list=my_nesting_list,max_recursion_limit=max_recursion_limit,include_extension=include_extension,extension_fields=extension_fields, extension_depth=extension_depth+1, max_extension_depth=max_extension_depth), True),
            {% endif%}
        {% endfor%}
            ]
        )
        if not include_extension:
            schema.fields = [c if c.name != "extension" else StructField("extension", StringType(), True) for c in schema.fields]

        {% if fhir_entity.cleaned_name == "Extension" %}
        if extension_fields:
            schema.fields = [
                c
                for c in schema.fields
                if c.name in extension_fields or c.name in ["id", "extension", "url"]
            ]
            schema.names = [
                n
                for n in schema.names
                if n in extension_fields or n in ["id", "extension", "url"]
            ]
        {%  endif %}
        return schema
    {%  endif %}
{%  endif %}
