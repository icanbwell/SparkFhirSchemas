from typing import Union, List, Optional, Any
from spark_auto_mapper.data_types.complex.complex_base import (
    AutoMapperDataTypeComplexBase,
)

from pyspark.sql.types import StructType, StructField, StringType, ArrayType, DateType, BooleanType, IntegerType, \
    DataType, FloatType, TimestampType

# noinspection PyPep8Naming
class AutoMapperElasticSearch{{resource.Name}}(AutoMapperDataTypeComplexBase):
    """
{%  if resource.Description %}
    {{ resource.Description | wordwrap(78) | replace('\n', '\n    ') | replace('\r', '\n    ') }}
{%  endif %}
    """
    # noinspection PyDefaultArgument
    def __init__(
        self,
    {% for property in properties%}
        {{ format_property(property.Name) }}: Optional[Any] = None,
    {% endfor %}
    ) -> None:
        super().__init__(
            {% for property in properties%}
                    {{ format_property(property.Name) }}={{ format_property(property.Name) }},
                {% endfor %}
        )
        super().include_null_properties(include_null_properties=True)
    @staticmethod
    def schema(max_nesting_depth: Optional[int] = 6, nesting_depth: int = 0, nesting_list: List[str] = [], max_recursion_limit: Optional[int] = 2, include_extension: Optional[bool] = False) -> Union[StructType, DataType]:
        """
    {%  if resource.Description %}
        {{ resource.Description | wordwrap(78) | replace('\n', '\n        ') }}


    {% for property in properties%}
        {{ property.Name }}: {{ property.Description | wordwrap(78) | replace("\n", "\n            ") | replace("\r", "\n            ")}}

    {%  endfor %}
{%  endif %}
        """
{% for property in properties %}
    {% if property.UnderlyingDataType and property.UnderlyingDataType not in ["string","boolean","date","number"] %}
        {%  if property.UnderlyingDataType != resource.Name and property.IsUniqueUnderlyingDataType %}
            {% if property.IsResourceType %}
        from spark_fhir_schemas.pss_r4.resources.{{property.UnderlyingDataType.lower()}} import AutoMapperElasticSearch{{property.UnderlyingDataType}} as {{property.UnderlyingDataType}}Schema
            {% elif property.IsSimpleType %}
        from spark_fhir_schemas.pss_r4.simple_types.{{property.UnderlyingDataType.lower()}} import AutoMapperElasticSearch{{property.UnderlyingDataType}} as {{property.UnderlyingDataType}}Schema
            {% elif property.IsComplexType %}
        from spark_fhir_schemas.pss_r4.complex_types.{{property.UnderlyingDataType.lower()}} import AutoMapperElasticSearch{{property.UnderlyingDataType}} as {{property.UnderlyingDataType}}Schema
            {% else %}
        Not mapped: {{ property.UnderlyingDataType }}
            {% endif %}
        {% endif %}
    {% endif %}
{% endfor %}
{% if not properties %}
{#    if it is a simple property #}
    {% if resource.Name.lower() == "datetime" %}
        return TimestampType()
    {% elif resource.Type == "date" or resource.Name.lower() == "date" %}
        return DateType()
    {% elif resource.Name == "decimal" %}
        return FloatType()
    {% elif resource.Type == "string" %}
        return StringType()
    {% elif resource.Type == "boolean" %}
        return BooleanType()
    {% elif resource.Type == "number" and "Decimal" in resource.Name %}
        return FloatType()
    {% elif resource.Type == "number" %}
        return IntegerType()
    {%  elif not resource.Type %}
        return StringType()
    {%  else %}
        Error: No mapping for {{ resource.Type }}
    {% endif %}
{%  else %}
        if (max_recursion_limit and nesting_list.count("{{resource.Name}}") >= max_recursion_limit) or (max_nesting_depth and nesting_depth >= max_nesting_depth):
{#            print("reached nesting_depth for {{resource.Name}}")#}
            return StructType([StructField("id", StringType(), True)])
    {%  if not properties or properties | length == 0 %}
        # Return at least one field in the struct or Spark throws an error
        # "Datasource does not support writing empty or nested empty schemas"
        return StructType([StructField("id", StringType(), True)])
    {%  else %}
        # add my name to recursion list for later
        my_nesting_list: List[str] = nesting_list+["{{resource.Name}}"]
        schema = StructType(
            [
        {% for property in properties%}
                # {{ property.Description | wordwrap(78) | replace("\n", "\n                # ") | replace("\r", "\n                # ")}}
            {% if property.HideExtension %}

                # >>> Hiding {{property.Name}} {{property.UnderlyingDataType}}

            {% elif property.Type == "array" %}
                {% if property.UnderlyingDataType and property.UnderlyingDataType not in ["string","boolean","date","number"] %}
                StructField("{{property.Name}}",ArrayType({{property.UnderlyingDataType}}Schema.schema(max_nesting_depth=max_nesting_depth,nesting_depth=nesting_depth+1,nesting_list=my_nesting_list,max_recursion_limit=max_recursion_limit,include_extension=include_extension)), True),
                {% elif property.Type == "date" or property.UnderlyingDataType == "date" %}
                StructField("{{property.Name}}",ArrayType(DateType()), True),
                {% elif (property.Type == "number" or property.UnderlyingDataType == "number") and ("Decimal" in property.Name) %}
                StructField("{{property.Name}}",ArrayType(FloatType()), True),
                {%  elif property.UnderlyingDataType == "string" %}
                StructField("{{property.Name}}",ArrayType(StringType()), True),
                {% elif property.Type == "boolean" or property.UnderlyingDataType == "boolean" %}
                StructField("{{property.Name}}",ArrayType(BooleanType()), True),
                {% elif property.Type == "number" or property.UnderlyingDataType == "number" %}
                StructField("{{property.Name}}",ArrayType(IntegerType()), True),
                {% endif %}
            {% elif not property.Type and not property.UnderlyingDataType %}
                StructField("{{property.Name}}", StringType(), True),
            {% elif property.Type == "date" or property.UnderlyingDataType == "date" %}
                StructField("{{property.Name}}", DateType(), True),
            {% elif (property.Type == "number" or property.UnderlyingDataType == "number") and ("Decimal" in property.Name) %}
                StructField("{{property.Name}}", FloatType(), True),
            {% elif (property.Type == "string" or property.UnderlyingDataType == "string") and ("DateTime" in property.Name) %}
                StructField("{{property.Name}}", TimestampType(), True),
            {% elif (property.Type == "string" or property.UnderlyingDataType == "string") and ("Date" in property.Name) %}
                StructField("{{property.Name}}", DateType(), True),
            {% elif property.Type == "string" or property.UnderlyingDataType == "string" %}
                StructField("{{property.Name}}", StringType(), True),
            {% elif property.Type == "boolean" or property.UnderlyingDataType == "boolean" %}
                StructField("{{property.Name}}", BooleanType(), True),
            {% elif property.Type == "number" or property.UnderlyingDataType == "number" %}
                StructField("{{property.Name}}", IntegerType(), True),
            {% else %}
                StructField("{{property.Name}}", {{property.UnderlyingDataType}}Schema.schema(max_nesting_depth=max_nesting_depth,nesting_depth=nesting_depth+1,nesting_list=my_nesting_list,max_recursion_limit=max_recursion_limit,include_extension=include_extension), True),
            {% endif%}
        {% endfor%}
            ]
        )
        if not include_extension:
            schema.fields = [c if c.name != "extension" else StructField("extension", StringType(), True) for c in schema.fields]
        return schema
    {%  endif %}
{%  endif %}
