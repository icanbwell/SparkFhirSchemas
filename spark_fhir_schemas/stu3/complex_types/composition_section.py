from typing import List
from typing import Optional
from typing import Union

from pyspark.sql.types import ArrayType
from pyspark.sql.types import DataType
from pyspark.sql.types import StringType
from pyspark.sql.types import StructField
from pyspark.sql.types import StructType


# This file is auto-generated by generate_schema so do not edit manually
# noinspection PyPep8Naming
class Composition_SectionSchema:
    """
    A set of healthcare-related information that is assembled together into a
    single logical document that provides a single coherent statement of meaning,
    establishes its own context and that has clinical attestation with regard to
    who is making the statement. While a Composition defines the structure, it
    does not actually contain the content: rather the full content of a document
    is contained in a Bundle, of which the Composition is the first resource
    contained.
    """
    # noinspection PyDefaultArgument
    @staticmethod
    def get_schema(
        max_nesting_depth: Optional[int] = 6,
        nesting_depth: int = 0,
        nesting_list: List[str] = [],
        max_recursion_limit: Optional[int] = 2,
        include_extension: Optional[bool] = False
    ) -> Union[StructType, DataType]:
        """
        A set of healthcare-related information that is assembled together into a
        single logical document that provides a single coherent statement of meaning,
        establishes its own context and that has clinical attestation with regard to
        who is making the statement. While a Composition defines the structure, it
        does not actually contain the content: rather the full content of a document
        is contained in a Bundle, of which the Composition is the first resource
        contained.


        title: The label for this particular section.  This will be part of the rendered
            content for the document, and is often used to build a table of contents.

        code: A code identifying the kind of content contained within the section. This must
            be consistent with the section title.

        text: A human-readable narrative that contains the attested content of the section,
            used to represent the content of the resource to a human. The narrative need
            not encode all the structured data, but is required to contain sufficient
            detail to make it "clinically safe" for a human to just read the narrative.

        mode: How the entry list was prepared - whether it is a working list that is
            suitable for being maintained on an ongoing basis, or if it represents a
            snapshot of a list of items from another source, or whether it is a prepared
            list where items may be marked as added, modified or deleted.

        orderedBy: Specifies the order applied to the items in the section entries.

        entry: A reference to the actual resource from which the narrative in the section is
            derived.

        emptyReason: If the section is empty, why the list is empty. An empty section typically has
            some text explaining the empty reason.

        section: A nested sub-section within this section.

        """
        from spark_fhir_schemas.stu3.complex_types.codeableconcept import CodeableConceptSchema
        from spark_fhir_schemas.stu3.complex_types.narrative import NarrativeSchema
        from spark_fhir_schemas.stu3.complex_types.reference import ReferenceSchema
        if (
            max_recursion_limit and
            nesting_list.count("Composition_Section") >= max_recursion_limit
        ) or (max_nesting_depth and nesting_depth >= max_nesting_depth):
            return StructType([StructField("id", StringType(), True)])
        # add my name to recursion list for later
        my_nesting_list: List[str] = nesting_list + ["Composition_Section"]
        schema = StructType(
            [
                # The label for this particular section.  This will be part of the rendered
                # content for the document, and is often used to build a table of contents.
                StructField("title", StringType(), True),
                # A code identifying the kind of content contained within the section. This must
                # be consistent with the section title.
                StructField(
                    "code",
                    CodeableConceptSchema.get_schema(
                        max_nesting_depth=max_nesting_depth,
                        nesting_depth=nesting_depth + 1,
                        nesting_list=my_nesting_list,
                        max_recursion_limit=max_recursion_limit,
                        include_extension=include_extension
                    ), True
                ),
                # A human-readable narrative that contains the attested content of the section,
                # used to represent the content of the resource to a human. The narrative need
                # not encode all the structured data, but is required to contain sufficient
                # detail to make it "clinically safe" for a human to just read the narrative.
                StructField(
                    "text",
                    NarrativeSchema.get_schema(
                        max_nesting_depth=max_nesting_depth,
                        nesting_depth=nesting_depth + 1,
                        nesting_list=my_nesting_list,
                        max_recursion_limit=max_recursion_limit,
                        include_extension=include_extension
                    ), True
                ),
                # How the entry list was prepared - whether it is a working list that is
                # suitable for being maintained on an ongoing basis, or if it represents a
                # snapshot of a list of items from another source, or whether it is a prepared
                # list where items may be marked as added, modified or deleted.
                StructField("mode", StringType(), True),
                # Specifies the order applied to the items in the section entries.
                StructField(
                    "orderedBy",
                    CodeableConceptSchema.get_schema(
                        max_nesting_depth=max_nesting_depth,
                        nesting_depth=nesting_depth + 1,
                        nesting_list=my_nesting_list,
                        max_recursion_limit=max_recursion_limit,
                        include_extension=include_extension
                    ), True
                ),
                # A reference to the actual resource from which the narrative in the section is
                # derived.
                StructField(
                    "entry",
                    ArrayType(
                        ReferenceSchema.get_schema(
                            max_nesting_depth=max_nesting_depth,
                            nesting_depth=nesting_depth + 1,
                            nesting_list=my_nesting_list,
                            max_recursion_limit=max_recursion_limit,
                            include_extension=include_extension
                        )
                    ), True
                ),
                # If the section is empty, why the list is empty. An empty section typically has
                # some text explaining the empty reason.
                StructField(
                    "emptyReason",
                    CodeableConceptSchema.get_schema(
                        max_nesting_depth=max_nesting_depth,
                        nesting_depth=nesting_depth + 1,
                        nesting_list=my_nesting_list,
                        max_recursion_limit=max_recursion_limit,
                        include_extension=include_extension
                    ), True
                ),
                # A nested sub-section within this section.
                StructField(
                    "section",
                    ArrayType(
                        Composition_SectionSchema.get_schema(
                            max_nesting_depth=max_nesting_depth,
                            nesting_depth=nesting_depth + 1,
                            nesting_list=my_nesting_list,
                            max_recursion_limit=max_recursion_limit,
                            include_extension=include_extension
                        )
                    ), True
                ),
            ]
        )
        if not include_extension:
            schema.fields = [
                c if c.name != "extension" else
                StructField("extension", StringType(), True)
                for c in schema.fields
            ]
        return schema
