from typing import Union, List, Optional

from pyspark.sql.types import StructType, StructField, StringType, ArrayType, DateType, BooleanType, IntegerType, \
    DataType


# This file is auto-generated by generate_schema so do not edit manually
# noinspection PyPep8Naming
class {{resource.Name}}Schema:
    """
{%  if resource.Description %}
    {{ resource.Description | wordwrap(78) | replace('\n', '\n    ') | replace('\r', '\n    ') }}
{%  endif %}
    """
    # noinspection PyDefaultArgument
    @staticmethod
    def get_schema(max_nesting_depth: Optional[int] = 6, nesting_depth: int = 0, nesting_list: List[str] = [], max_recursion_limit: Optional[int] = 2, include_extension: Optional[bool] = False) -> Union[StructType, DataType]:
        """
{%  if resource.Description %}
        {{ resource.Description | wordwrap(78) | replace('\n', '\n        ') }}


    {% for property in properties%}
        {{ property.Name }}: {{ property.Description | wordwrap(78) | replace("\n", "\n            ") | replace("\r", "\n            ")}}

    {%  endfor %}
{%  endif %}
        """
{% for property in properties %}
    {% if property.UnderlyingDataType and property.UnderlyingDataType not in ["string","boolean","date","number"] %}
        {%  if property.UnderlyingDataType != resource.Name and property.IsUniqueUnderlyingDataType %}
            {% if property.IsResourceType %}
        from spark_fhir_schemas.r4.resources.{{property.UnderlyingDataType.lower()}} import {{property.UnderlyingDataType}}Schema
            {% elif property.IsSimpleType %}
        from spark_fhir_schemas.r4.simple_types.{{property.UnderlyingDataType.lower()}} import {{property.UnderlyingDataType}}Schema
            {% elif property.IsComplexType %}
        from spark_fhir_schemas.r4.complex_types.{{property.UnderlyingDataType.lower()}} import {{property.UnderlyingDataType}}Schema
            {% else %}
        Not mapped: {{ property.UnderlyingDataType }}
            {% endif %}
        {% endif %}
    {% endif %}
{% endfor %}
{% if not properties %}
{#    if it is a simple property #}
    {% if resource.Type == "string" %}
        return StringType()
    {% elif resource.Type == "boolean" %}
        return BooleanType()
    {% elif resource.Type == "date" %}
        return DateType()
    {% elif resource.Type == "number" %}
        return IntegerType()
    {%  elif not resource.Type %}
        return StringType()
    {%  else %}
        Error: No mapping for {{ resource.Type }}
    {% endif %}
{%  else %}
        if (max_recursion_limit and nesting_list.count("{{resource.Name}}") >= max_recursion_limit) or (max_nesting_depth and nesting_depth >= max_nesting_depth):
{#            print("reached nesting_depth for {{resource.Name}}")#}
            return StructType([StructField("id", StringType(), True)])
    {%  if not properties or properties | length == 0 %}
        # Return at least one field in the struct or Spark throws an error
        # "Datasource does not support writing empty or nested empty schemas"
        return StructType([StructField("id", StringType(), True)])
    {%  else %}
        # add my name to recursion list for later
        my_nesting_list: List[str] = nesting_list+["{{resource.Name}}"]
        schema = StructType(
            [
        {% for property in properties%}
                # {{ property.Description | wordwrap(78) | replace("\n", "\n                # ") | replace("\r", "\n                # ")}}
            {% if property.HideExtension %}

                # >>> Hiding {{property.Name}} {{property.UnderlyingDataType}}

            {% elif property.Type == "array" %}
                {% if property.UnderlyingDataType and property.UnderlyingDataType not in ["string","boolean","date","number"] %}
                StructField("{{property.Name}}",ArrayType({{property.UnderlyingDataType}}Schema.get_schema(max_nesting_depth=max_nesting_depth,nesting_depth=nesting_depth+1,nesting_list=my_nesting_list,max_recursion_limit=max_recursion_limit,include_extension=include_extension)), True),
                {%  elif property.UnderlyingDataType == "string" %}
                StructField("{{property.Name}}",ArrayType(StringType()), True),
                {% elif property.Type == "boolean" or property.UnderlyingDataType == "boolean" %}
                StructField("{{property.Name}}",ArrayType(BooleanType()), True),
                {% elif property.Type == "date" or property.UnderlyingDataType == "date" %}
                StructField("{{property.Name}}",ArrayType(DateType()), True),
                {% elif property.Type == "number" or property.UnderlyingDataType == "number" %}
                StructField("{{property.Name}}",ArrayType(IntegerType()), True),
                {% endif %}
            {% elif not property.Type and not property.UnderlyingDataType %}
                StructField("{{property.Name}}", StringType(), True),
            {% elif property.Type == "string" or property.UnderlyingDataType == "string" %}
                StructField("{{property.Name}}", StringType(), True),
            {% elif property.Type == "boolean" or property.UnderlyingDataType == "boolean" %}
                StructField("{{property.Name}}", BooleanType(), True),
            {% elif property.Type == "date" or property.UnderlyingDataType == "date" %}
                StructField("{{property.Name}}", DateType(), True),
            {% elif property.Type == "number" or property.UnderlyingDataType == "number" %}
                StructField("{{property.Name}}", IntegerType(), True),
            {% else %}
                StructField("{{property.Name}}", {{property.UnderlyingDataType}}Schema.get_schema(max_nesting_depth=max_nesting_depth,nesting_depth=nesting_depth+1,nesting_list=my_nesting_list,max_recursion_limit=max_recursion_limit,include_extension=include_extension), True),
            {% endif%}
        {% endfor%}
            ]
        )
        if not include_extension:
            schema.fields = [c if c.name != "extension" else StructField("extension", StringType(), True) for c in schema.fields]
        return schema
    {%  endif %}
{%  endif %}
