from typing import Union, List

from pyspark.sql.types import StructType, StructField, StringType, ArrayType, DateType, BooleanType, IntegerType, \
    DataType


# This file is auto-generated by generate_schema so do not edit manually
# noinspection PyPep8Naming
class {{resource.Name}}Schema:
    """
{%  if resource.Description %}
    {{ resource.Description | wordwrap(78) | replace('\n', '\n    ') | replace('\r', '\n    ') }}
{%  endif %}
    """
    # noinspection PyDefaultArgument
    @staticmethod
    def get_schema(max_recursion_depth: int = 4, recursion_depth: int = 0, recursion_list: List[str] = []) -> Union[StructType, DataType]:
        """
{%  if resource.Description %}
        {{ resource.Description | wordwrap(78) | replace('\n', '\n        ') }}


    {% for property in properties%}
        {{ property.Name }}: {{ property.Description | wordwrap(78) | replace("\n", "\n            ") | replace("\r", "\n            ")}}

    {%  endfor %}
{%  endif %}
        """
{% for property in properties %}
    {% if property.UnderlyingDataType and property.UnderlyingDataType not in ["string","boolean","date","number"] %}
        {%  if property.UnderlyingDataType != resource.Name and property.IsUniqueUnderlyingDataType %}
            {% if property.IsResourceType %}
        from spark_fhir_schemas.r4.resources.{{property.UnderlyingDataType.lower()}} import {{property.UnderlyingDataType}}Schema
            {% elif property.IsSimpleType %}
        from spark_fhir_schemas.r4.simple_types.{{property.UnderlyingDataType.lower()}} import {{property.UnderlyingDataType}}Schema
            {% elif property.IsComplexType %}
        from spark_fhir_schemas.r4.complex_types.{{property.UnderlyingDataType.lower()}} import {{property.UnderlyingDataType}}Schema
            {% else %}
        Not mapped: {{ property.UnderlyingDataType }}
            {% endif %}
        {% endif %}
    {% endif %}
{% endfor %}
{% if not properties %}
{#    if it is a simple property #}
    {% if resource.Type == "string" %}
        return StringType()
    {% elif resource.Type == "boolean" %}
        return BooleanType()
    {% elif resource.Type == "date" %}
        return DateType()
    {% elif resource.Type == "number" %}
        return IntegerType()
    {%  elif not resource.Type %}
        return StringType()
    {%  else %}
        Error: No mapping for {{ resource.Type }}
    {% endif %}
{%  else %}
        if recursion_list.count("{{resource.Name}}") >= 2 or recursion_depth >= max_recursion_depth:
{#            print("reached recursion_depth for {{resource.Name}}")#}
            return StructType([StructField("id", StringType(), True)])
    {%  if not properties or properties | length == 0 %}
        # Return at least one field in the struct or Spark throws an error
        # "Datasource does not support writing empty or nested empty schemas"
        return StructType([StructField("id", StringType(), True)])
    {%  else %}
        # add my name to recursion list for later
        my_recursion_list: List[str] = recursion_list+["{{resource.Name}}"]
        schema = StructType(
            [
        {% for property in properties%}
                # {{ property.Description | wordwrap(78) | replace("\n", "\n                # ") | replace("\r", "\n                # ")}}
            {% if property.Type == "array" %}
                {% if property.UnderlyingDataType and property.UnderlyingDataType not in ["string","boolean","date","number"] %}
                StructField("{{property.Name}}",ArrayType({{property.UnderlyingDataType}}Schema.get_schema(max_recursion_depth=max_recursion_depth,recursion_depth=recursion_depth+1,recursion_list=my_recursion_list)), True),
                {%  elif property.UnderlyingDataType == "string" %}
                StructField("{{property.Name}}",ArrayType(StringType()), True),
                {% elif property.Type == "boolean" or property.UnderlyingDataType == "boolean" %}
                StructField("{{property.Name}}",ArrayType(BooleanType()), True),
                {% elif property.Type == "date" or property.UnderlyingDataType == "date" %}
                StructField("{{property.Name}}",ArrayType(DateType()), True),
                {% elif property.Type == "number" or property.UnderlyingDataType == "number" %}
                StructField("{{property.Name}}",ArrayType(IntegerType()), True),
                {% endif %}
            {% elif not property.Type and not property.UnderlyingDataType %}
                StructField("{{property.Name}}", StringType(), True),
            {% elif property.Type == "string" or property.UnderlyingDataType == "string" %}
                StructField("{{property.Name}}", StringType(), True),
            {% elif property.Type == "boolean" or property.UnderlyingDataType == "boolean" %}
                StructField("{{property.Name}}", BooleanType(), True),
            {% elif property.Type == "date" or property.UnderlyingDataType == "date" %}
                StructField("{{property.Name}}", DateType(), True),
            {% elif property.Type == "number" or property.UnderlyingDataType == "number" %}
                StructField("{{property.Name}}", IntegerType(), True),
            {% else %}
                StructField("{{property.Name}}", {{property.UnderlyingDataType}}Schema.get_schema(max_recursion_depth=max_recursion_depth,recursion_depth=recursion_depth+1,recursion_list=my_recursion_list), True),
            {% endif%}
        {% endfor%}
            ]
        )
        return schema
    {%  endif %}
{%  endif %}
